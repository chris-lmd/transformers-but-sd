<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flux d'Entra√Ænement - Forward & Backward</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 15px;
            color: #fff;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #4fc3f7, #e91e63, #66bb6a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Controls */
        .controls-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .controls-panel h2 {
            color: #4fc3f7;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
        }

        .phase-indicator {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .phase {
            text-align: center;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .phase:hover {
            background: rgba(255,255,255,0.1);
        }

        .phase.active.forward {
            background: rgba(79, 195, 247, 0.3);
            border: 2px solid #4fc3f7;
        }

        .phase.active.loss {
            background: rgba(233, 30, 99, 0.3);
            border: 2px solid #e91e63;
        }

        .phase.active.backward {
            background: rgba(102, 187, 106, 0.3);
            border: 2px solid #66bb6a;
        }

        .phase.active.update {
            background: rgba(255, 152, 0, 0.3);
            border: 2px solid #ffa726;
        }

        .phase-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .phase-name {
            font-size: 12px;
            color: #888;
        }

        .phase.active .phase-name {
            color: #fff;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .btn.primary {
            background: #4fc3f7;
            color: #000;
        }

        .btn.primary:hover {
            background: #81d4fa;
        }

        .btn.secondary {
            background: #333;
            color: #fff;
            border: 1px solid #555;
        }

        .btn.secondary:hover {
            background: #444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Step info */
        .step-info {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .step-counter {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
        }

        .step-counter .num {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 18px;
        }

        .step-title {
            font-size: 16px;
            color: #fff;
            margin-bottom: 8px;
        }

        .step-description {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }

        .step-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
            padding: 8px 12px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }

        /* Legend */
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .legend h4 {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 11px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-color.forward {
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
        }

        .legend-color.loss {
            background: linear-gradient(135deg, #e91e63, #c2185b);
        }

        .legend-color.backward {
            background: linear-gradient(135deg, #66bb6a, #43a047);
        }

        .legend-color.update {
            background: linear-gradient(135deg, #ffa726, #f57c00);
        }

        /* Visualization panel */
        .viz-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            overflow-x: auto;
        }

        /* Architecture diagram */
        .architecture {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-height: 500px;
            padding: 20px;
        }

        .layer {
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
        }

        .block {
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 12px;
            transition: all 0.5s;
            position: relative;
            min-width: 120px;
        }

        .block.output {
            background: linear-gradient(135deg, #e91e63, #c2185b);
            border: 2px solid #e91e63;
        }

        .block.lm-head {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
            border: 2px solid #9c27b0;
        }

        .block.decoder {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            border: 2px solid #ff9800;
        }

        .block.embed {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            border: 2px solid #2196f3;
        }

        .block.input {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            border: 2px solid #4caf50;
        }

        .block.loss {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            border: 2px solid #f44336;
        }

        .block.target {
            background: linear-gradient(135deg, #607d8b, #455a64);
            border: 2px solid #607d8b;
        }

        .block.weights {
            background: linear-gradient(135deg, #795548, #5d4037);
            border: 2px solid #795548;
            font-size: 10px;
        }

        .block.gradient {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            border: 2px solid #66bb6a;
        }

        /* Activation states */
        .block.active-forward {
            box-shadow: 0 0 20px #4fc3f7, inset 0 0 20px rgba(79, 195, 247, 0.3);
            transform: scale(1.05);
        }

        .block.active-loss {
            box-shadow: 0 0 20px #e91e63, inset 0 0 20px rgba(233, 30, 99, 0.3);
            transform: scale(1.05);
        }

        .block.active-backward {
            box-shadow: 0 0 20px #66bb6a, inset 0 0 20px rgba(102, 187, 106, 0.3);
            transform: scale(1.05);
        }

        .block.active-update {
            box-shadow: 0 0 20px #ffa726, inset 0 0 20px rgba(255, 152, 0, 0.3);
            transform: scale(1.05);
        }

        .block .dim {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 3px;
        }

        /* Arrows */
        .arrow {
            width: 2px;
            height: 25px;
            background: #555;
            position: relative;
        }

        .arrow.forward {
            background: #4fc3f7;
        }

        .arrow.forward::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: -4px;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #4fc3f7;
        }

        .arrow.backward {
            background: #66bb6a;
        }

        .arrow.backward::after {
            content: '';
            position: absolute;
            top: -6px;
            left: -4px;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 6px solid #66bb6a;
        }

        .arrow-horizontal {
            width: 30px;
            height: 2px;
            background: #555;
            position: relative;
        }

        .arrow-horizontal.forward {
            background: #4fc3f7;
        }

        .arrow-horizontal.forward::after {
            content: '';
            position: absolute;
            right: -6px;
            top: -4px;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 6px solid #4fc3f7;
        }

        /* Data flow animation */
        .data-packet {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: flowDown 0.5s ease-in-out;
        }

        .data-packet.forward {
            background: #4fc3f7;
            box-shadow: 0 0 10px #4fc3f7;
        }

        .data-packet.backward {
            background: #66bb6a;
            box-shadow: 0 0 10px #66bb6a;
            animation: flowUp 0.5s ease-in-out;
        }

        @keyframes flowDown {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes flowUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Value displays */
        .value-display {
            position: absolute;
            right: -80px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-family: monospace;
            white-space: nowrap;
        }

        .value-display.forward { color: #4fc3f7; border: 1px solid #4fc3f7; }
        .value-display.loss { color: #e91e63; border: 1px solid #e91e63; }
        .value-display.backward { color: #66bb6a; border: 1px solid #66bb6a; }
        .value-display.update { color: #ffa726; border: 1px solid #ffa726; }

        /* Gradient flow visualization */
        .gradient-flow {
            position: absolute;
            left: -25px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: transparent;
            transition: all 0.5s;
        }

        .gradient-flow.active {
            background: linear-gradient(to top, #66bb6a, transparent);
            box-shadow: 0 0 10px #66bb6a;
        }

        /* Info boxes */
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .info-section h4 {
            color: #4fc3f7;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .info-section.loss h4 { color: #e91e63; }
        .info-section.backward h4 { color: #66bb6a; }
        .info-section.update h4 { color: #ffa726; }

        .info-section p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
        }

        .info-section code {
            background: rgba(255,255,255,0.1);
            padding: 1px 4px;
            border-radius: 3px;
            color: #4fc3f7;
        }

        /* Matrix visualizations */
        .matrix-section {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
        }

        .matrix-container {
            text-align: center;
        }

        .matrix-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .matrix {
            display: grid;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 6px;
            border: 2px solid #333;
        }

        .matrix.forward { border-color: #4fc3f7; }
        .matrix.loss { border-color: #e91e63; }
        .matrix.gradient { border-color: #66bb6a; }

        .matrix-cell {
            width: 40px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-family: monospace;
            background: rgba(255,255,255,0.05);
            border-radius: 2px;
            transition: all 0.3s;
        }

        .matrix-cell.positive { color: #66bb6a; }
        .matrix-cell.negative { color: #ef5350; }
        .matrix-cell.highlight { background: rgba(79, 195, 247, 0.3); }

        /* Epoch progress */
        .epoch-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            text-align: center;
        }

        .epoch-label {
            font-size: 11px;
            color: #888;
        }

        .epoch-value {
            font-size: 20px;
            color: #ffa726;
            font-weight: bold;
        }

        .loss-value {
            font-size: 14px;
            margin-top: 5px;
        }

        .loss-value span {
            color: #e91e63;
        }
    </style>
</head>
<body>
    <h1>Flux d'Entra√Ænement</h1>
    <p class="subtitle">Forward Pass ‚Üí Loss ‚Üí Backward Pass ‚Üí Update</p>

    <div class="main-layout">
        <!-- Controls -->
        <div class="controls-panel">
            <h2>Contr√¥les</h2>

            <div class="phase-indicator">
                <div class="phase active forward" onclick="goToPhase('forward')">
                    <div class="phase-icon">‚Üí</div>
                    <div class="phase-name">Forward</div>
                </div>
                <div class="phase" onclick="goToPhase('loss')">
                    <div class="phase-icon">üìâ</div>
                    <div class="phase-name">Loss</div>
                </div>
                <div class="phase" onclick="goToPhase('backward')">
                    <div class="phase-icon">‚Üê</div>
                    <div class="phase-name">Backward</div>
                </div>
                <div class="phase" onclick="goToPhase('update')">
                    <div class="phase-icon">‚Üª</div>
                    <div class="phase-name">Update</div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn secondary" onclick="prevStep()" id="prev-btn">‚Üê Pr√©c√©dent</button>
                <button class="btn primary" onclick="nextStep()" id="next-btn">Suivant ‚Üí</button>
            </div>

            <div class="btn-group">
                <button class="btn secondary" onclick="resetAnimation()">‚Ü∫ Reset</button>
                <button class="btn secondary" onclick="autoPlay()" id="auto-btn">‚è© Auto</button>
            </div>

            <div class="step-info">
                <div class="step-counter">√âtape <span class="num" id="step-num">1</span> / <span id="total-steps">12</span></div>
                <div class="step-title" id="step-title">Forward : Entr√©e</div>
                <div class="step-description" id="step-desc">Les tokens d'entr√©e sont convertis en embeddings.</div>
                <div class="step-formula" id="step-formula">X = E[tokens] + PE</div>
            </div>

            <div class="epoch-info">
                <div class="epoch-label">Iteration</div>
                <div class="epoch-value" id="epoch-num">1</div>
                <div class="loss-value">Loss : <span id="loss-value">2.45</span></div>
            </div>

            <div class="legend">
                <h4>L√©gende</h4>
                <div class="legend-item">
                    <div class="legend-color forward"></div>
                    <span>Forward pass (donn√©es ‚Üí pr√©dictions)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color loss"></div>
                    <span>Calcul de la loss</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color backward"></div>
                    <span>Backward pass (gradients)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color update"></div>
                    <span>Mise √† jour des poids</span>
                </div>
            </div>
        </div>

        <!-- Visualization -->
        <div class="viz-panel">
            <div class="architecture" id="architecture">
                <!-- Will be populated by JS -->
            </div>

            <div id="detail-section"></div>
        </div>
    </div>

    <script>
        let currentStep = 0;
        let iteration = 1;
        let currentLoss = 2.45;
        let autoPlayInterval = null;

        const steps = [
            // Forward pass
            {
                phase: 'forward',
                title: 'Forward : Entr√©e',
                desc: 'Les tokens d\'entr√©e sont convertis en indices, puis en embeddings denses.',
                formula: 'X = E[tokens] + PE',
                activeBlocks: ['input'],
                detail: `
                    <div class="info-section">
                        <h4>Tokenization & Embedding</h4>
                        <p><strong>1. Tokenization</strong> : "Le chat" ‚Üí [1, 2]</p>
                        <p style="margin-top:5px;"><strong>2. Embedding lookup</strong> : Chaque indice r√©cup√®re sa ligne dans la matrice E.</p>
                        <p style="margin-top:5px;"><strong>3. Position</strong> : On ajoute l'encodage positionnel.</p>
                        <p style="margin-top:10px;"><code>X.shape = (seq_len, embed_dim)</code></p>
                    </div>
                `
            },
            {
                phase: 'forward',
                title: 'Forward : Embedding',
                desc: 'La matrice d\'embedding transforme les indices en vecteurs denses.',
                formula: 'X_emb = E[ids], X = X_emb + PE',
                activeBlocks: ['embed'],
                detail: `
                    <div class="info-section">
                        <h4>Lookup dans la matrice E</h4>
                        <p>La matrice E contient un vecteur appris pour chaque token du vocabulaire.</p>
                        <div class="matrix-section">
                            <div class="matrix-container">
                                <div class="matrix-label">E (vocab √ó embed)</div>
                                <div class="matrix forward" style="grid-template-columns: repeat(4, 40px);">
                                    <div class="matrix-cell">0.12</div><div class="matrix-cell">-0.34</div><div class="matrix-cell">0.56</div><div class="matrix-cell">...</div>
                                    <div class="matrix-cell highlight">0.45</div><div class="matrix-cell highlight">0.23</div><div class="matrix-cell highlight">-0.12</div><div class="matrix-cell highlight">...</div>
                                    <div class="matrix-cell highlight">-0.67</div><div class="matrix-cell highlight">0.89</div><div class="matrix-cell highlight">0.01</div><div class="matrix-cell highlight">...</div>
                                    <div class="matrix-cell">...</div><div class="matrix-cell">...</div><div class="matrix-cell">...</div><div class="matrix-cell">...</div>
                                </div>
                            </div>
                        </div>
                        <p style="margin-top:10px;">Les lignes 1 et 2 (surlign√©es) sont extraites pour "Le" et "chat".</p>
                    </div>
                `
            },
            {
                phase: 'forward',
                title: 'Forward : D√©codeur',
                desc: 'Les couches Transformer traitent la s√©quence : Self-Attention + FFN.',
                formula: 'H = Transformer(X)',
                activeBlocks: ['decoder'],
                detail: `
                    <div class="info-section">
                        <h4>Bloc D√©codeur (√óN)</h4>
                        <p>Chaque bloc contient :</p>
                        <ul style="margin-left:15px;margin-top:5px;font-size:11px;color:#aaa;">
                            <li><strong>Self-Attention</strong> : m√©lange l'information entre positions</li>
                            <li><strong>Add & Norm</strong> : connexion r√©siduelle + normalisation</li>
                            <li><strong>FFN</strong> : transformation non-lin√©aire par position</li>
                            <li><strong>Add & Norm</strong> : connexion r√©siduelle + normalisation</li>
                        </ul>
                        <p style="margin-top:10px;">La sortie H a la m√™me shape que l'entr√©e X.</p>
                    </div>
                `
            },
            {
                phase: 'forward',
                title: 'Forward : LM Head',
                desc: 'Projection vers le vocabulaire pour obtenir les logits.',
                formula: 'logits = H √ó W_lm^T',
                activeBlocks: ['lm-head'],
                detail: `
                    <div class="info-section">
                        <h4>Projection vers vocabulaire</h4>
                        <p>Le LM Head projette les repr√©sentations cach√©es vers la dimension du vocabulaire :</p>
                        <p style="margin-top:10px;"><code>H : (seq, embed) ‚Üí logits : (seq, vocab)</code></p>
                        <p style="margin-top:10px;"><strong>Weight tying</strong> : W_lm = E·µÄ (partage avec embedding).</p>
                    </div>
                `
            },
            {
                phase: 'forward',
                title: 'Forward : Softmax',
                desc: 'Les logits sont convertis en probabilit√©s via softmax.',
                formula: 'P = softmax(logits)',
                activeBlocks: ['output'],
                detail: `
                    <div class="info-section">
                        <h4>Pr√©dictions</h4>
                        <p>Softmax normalise les logits en distribution de probabilit√©s :</p>
                        <div class="matrix-section">
                            <div class="matrix-container">
                                <div class="matrix-label">Pr√©dictions (derni√®re position)</div>
                                <div class="matrix forward" style="grid-template-columns: repeat(5, 40px);">
                                    <div class="matrix-cell">0.05</div>
                                    <div class="matrix-cell">0.08</div>
                                    <div class="matrix-cell positive">0.42</div>
                                    <div class="matrix-cell">0.25</div>
                                    <div class="matrix-cell">0.20</div>
                                </div>
                            </div>
                        </div>
                        <p style="margin-top:10px;">Le mod√®le pr√©dit "mange" (42%) pour suivre "Le chat".</p>
                    </div>
                `
            },
            // Loss
            {
                phase: 'loss',
                title: 'Loss : Comparaison',
                desc: 'On compare les pr√©dictions avec la cible r√©elle (teacher forcing).',
                formula: 'Loss = -log(P[target])',
                activeBlocks: ['output', 'target', 'loss-block'],
                detail: `
                    <div class="info-section loss">
                        <h4>Cross-Entropy Loss</h4>
                        <p>La loss mesure la "surprise" du mod√®le face √† la vraie r√©ponse :</p>
                        <p style="margin-top:10px;"><code>Loss = -Œ£ log(P[y_true])</code></p>
                        <p style="margin-top:10px;">Si le mod√®le est s√ªr de la bonne r√©ponse (P ‚âà 1), loss ‚âà 0.</p>
                        <p>Si le mod√®le est surpris (P ‚âà 0), loss ‚Üí ‚àû.</p>
                        <div style="margin-top:15px;padding:10px;background:rgba(233,30,99,0.2);border-radius:8px;">
                            <p style="color:#e91e63;"><strong>Loss actuelle : ${currentLoss.toFixed(3)}</strong></p>
                        </div>
                    </div>
                `
            },
            // Backward pass
            {
                phase: 'backward',
                title: 'Backward : Gradient de sortie',
                desc: 'Le gradient de la loss par rapport aux logits est calcul√©.',
                formula: '‚àÇL/‚àÇlogits = P - y_true',
                activeBlocks: ['output', 'lm-head'],
                detail: `
                    <div class="info-section backward">
                        <h4>Gradient de sortie</h4>
                        <p>Pour cross-entropy + softmax, le gradient est simple :</p>
                        <p style="margin-top:10px;"><code>‚àÇL/‚àÇlogits = predictions - target_onehot</code></p>
                        <div class="matrix-section">
                            <div class="matrix-container">
                                <div class="matrix-label">‚àÇL/‚àÇlogits</div>
                                <div class="matrix gradient" style="grid-template-columns: repeat(5, 40px);">
                                    <div class="matrix-cell positive">0.05</div>
                                    <div class="matrix-cell positive">0.08</div>
                                    <div class="matrix-cell negative">-0.58</div>
                                    <div class="matrix-cell positive">0.25</div>
                                    <div class="matrix-cell positive">0.20</div>
                                </div>
                            </div>
                        </div>
                        <p style="margin-top:10px;">Le gradient n√©gatif sur "mange" pousse le mod√®le √† augmenter cette probabilit√©.</p>
                    </div>
                `
            },
            {
                phase: 'backward',
                title: 'Backward : Chain Rule (LM Head)',
                desc: 'Les gradients remontent √† travers le LM Head.',
                formula: '‚àÇL/‚àÇH = ‚àÇL/‚àÇlogits √ó W_lm',
                activeBlocks: ['lm-head'],
                detail: `
                    <div class="info-section backward">
                        <h4>Backprop √† travers la projection</h4>
                        <p>La r√®gle de cha√Æne propage le gradient :</p>
                        <p style="margin-top:10px;"><code>‚àÇL/‚àÇW_lm = H·µÄ √ó ‚àÇL/‚àÇlogits</code> (gradient des poids)</p>
                        <p><code>‚àÇL/‚àÇH = ‚àÇL/‚àÇlogits √ó W_lm</code> (gradient √† propager)</p>
                    </div>
                `
            },
            {
                phase: 'backward',
                title: 'Backward : Chain Rule (D√©codeur)',
                desc: 'Les gradients traversent le bloc d√©codeur.',
                formula: '‚àÇL/‚àÇX = Backprop(‚àÇL/‚àÇH)',
                activeBlocks: ['decoder'],
                detail: `
                    <div class="info-section backward">
                        <h4>Backprop √† travers le Transformer</h4>
                        <p>Les gradients remontent √† travers :</p>
                        <ul style="margin-left:15px;margin-top:5px;font-size:11px;color:#aaa;">
                            <li><strong>FFN</strong> : ‚àÇL/‚àÇW_ffn1, ‚àÇL/‚àÇW_ffn2</li>
                            <li><strong>LayerNorm</strong> : ‚àÇL/‚àÇŒ≥, ‚àÇL/‚àÇŒ≤</li>
                            <li><strong>Attention</strong> : ‚àÇL/‚àÇW_Q, ‚àÇL/‚àÇW_K, ‚àÇL/‚àÇW_V, ‚àÇL/‚àÇW_O</li>
                        </ul>
                        <p style="margin-top:10px;"><strong>Connexions r√©siduelles</strong> : permettent au gradient de "sauter" directement via le +.</p>
                    </div>
                `
            },
            {
                phase: 'backward',
                title: 'Backward : Embedding',
                desc: 'Les gradients arrivent jusqu\'√† la matrice d\'embedding.',
                formula: '‚àÇL/‚àÇE = scatter_add(‚àÇL/‚àÇX)',
                activeBlocks: ['embed'],
                detail: `
                    <div class="info-section backward">
                        <h4>Gradient de l'embedding</h4>
                        <p>Seules les lignes utilis√©es de E re√ßoivent un gradient :</p>
                        <p style="margin-top:10px;"><code>E[token_id] -= lr √ó ‚àÇL/‚àÇX[position]</code></p>
                        <p style="margin-top:10px;">C'est un <strong>sparse update</strong> : on ne touche que les lignes vues dans le batch.</p>
                    </div>
                `
            },
            // Update
            {
                phase: 'update',
                title: 'Update : Optimiseur',
                desc: 'L\'optimiseur (Adam) met √† jour tous les poids.',
                formula: 'Œ∏ = Œ∏ - lr √ó Adam(‚àáŒ∏)',
                activeBlocks: ['weights'],
                detail: `
                    <div class="info-section update">
                        <h4>Adam Optimizer</h4>
                        <p>Adam combine momentum et RMSprop :</p>
                        <ul style="margin-left:15px;margin-top:5px;font-size:11px;color:#aaa;">
                            <li><strong>m</strong> = Œ≤‚ÇÅ √ó m + (1-Œ≤‚ÇÅ) √ó g (momentum)</li>
                            <li><strong>v</strong> = Œ≤‚ÇÇ √ó v + (1-Œ≤‚ÇÇ) √ó g¬≤ (variance)</li>
                            <li><strong>Œ∏</strong> = Œ∏ - lr √ó m / (‚àöv + Œµ)</li>
                        </ul>
                        <p style="margin-top:10px;">Typiquement : lr=3e-4, Œ≤‚ÇÅ=0.9, Œ≤‚ÇÇ=0.999</p>
                    </div>
                `
            },
            {
                phase: 'update',
                title: 'Update : Nouvelle it√©ration',
                desc: 'Les poids sont mis √† jour. Pr√™t pour le prochain batch !',
                formula: 'iteration += 1',
                activeBlocks: [],
                detail: `
                    <div class="info-section update">
                        <h4>Cycle complet</h4>
                        <p>Un <strong>pas d'entra√Ænement</strong> est termin√© :</p>
                        <ol style="margin-left:15px;margin-top:5px;font-size:11px;color:#aaa;">
                            <li>Forward : donn√©es ‚Üí pr√©dictions</li>
                            <li>Loss : pr√©dictions vs cible</li>
                            <li>Backward : loss ‚Üí gradients</li>
                            <li>Update : gradients ‚Üí nouveaux poids</li>
                        </ol>
                        <p style="margin-top:15px;">La loss devrait diminuer progressivement au fil des it√©rations.</p>
                        <div style="margin-top:15px;padding:10px;background:rgba(255,152,0,0.2);border-radius:8px;">
                            <p style="color:#ffa726;"><strong>Nouvelle loss : ${(currentLoss * 0.95).toFixed(3)}</strong></p>
                        </div>
                    </div>
                `
            }
        ];

        function renderArchitecture() {
            const container = document.getElementById('architecture');
            const step = steps[currentStep];

            let html = `
                <!-- Output -->
                <div class="layer">
                    <div class="block output ${step.activeBlocks.includes('output') ? 'active-' + step.phase : ''}" id="block-output">
                        Pr√©dictions (softmax)
                        <div class="dim">(seq, vocab)</div>
                    </div>
                </div>

                <div class="arrow ${step.phase === 'forward' && step.activeBlocks.includes('output') ? 'forward' : ''} ${step.phase === 'backward' && step.activeBlocks.includes('output') ? 'backward' : ''}"></div>

                <!-- LM Head -->
                <div class="layer">
                    <div class="block lm-head ${step.activeBlocks.includes('lm-head') ? 'active-' + step.phase : ''}" id="block-lm-head">
                        LM Head (E·µÄ)
                        <div class="dim">(embed, vocab)</div>
                    </div>
                </div>

                <div class="arrow ${step.phase === 'forward' && step.activeBlocks.includes('lm-head') ? 'forward' : ''} ${step.phase === 'backward' && step.activeBlocks.includes('decoder') ? 'backward' : ''}"></div>

                <!-- Decoder -->
                <div class="layer">
                    <div class="block decoder ${step.activeBlocks.includes('decoder') ? 'active-' + step.phase : ''}" id="block-decoder">
                        D√©codeur √óN
                        <div class="dim">Self-Attn + FFN</div>
                    </div>
                    <div class="block weights ${step.activeBlocks.includes('weights') ? 'active-update' : ''}" style="position:absolute;left:-100px;">
                        W_Q, W_K, W_V<br>W_O, W_ffn
                    </div>
                </div>

                <div class="arrow ${step.phase === 'forward' && step.activeBlocks.includes('decoder') ? 'forward' : ''} ${step.phase === 'backward' && step.activeBlocks.includes('embed') ? 'backward' : ''}"></div>

                <!-- Embedding -->
                <div class="layer">
                    <div class="block embed ${step.activeBlocks.includes('embed') ? 'active-' + step.phase : ''}" id="block-embed">
                        Embedding + PE
                        <div class="dim">(vocab, embed)</div>
                    </div>
                    <div class="block weights ${step.activeBlocks.includes('weights') ? 'active-update' : ''}" style="position:absolute;left:-100px;">
                        E, PE
                    </div>
                </div>

                <div class="arrow ${step.phase === 'forward' && step.activeBlocks.includes('embed') ? 'forward' : ''} ${step.phase === 'backward' && step.activeBlocks.includes('input') ? 'backward' : ''}"></div>

                <!-- Input -->
                <div class="layer">
                    <div class="block input ${step.activeBlocks.includes('input') ? 'active-' + step.phase : ''}" id="block-input">
                        Input : "Le chat"
                        <div class="dim">[1, 2]</div>
                    </div>
                </div>
            `;

            // Add loss/target blocks for loss phase
            if (step.phase === 'loss' || step.activeBlocks.includes('loss-block')) {
                html = `
                    <!-- Loss -->
                    <div class="layer" style="margin-bottom:20px;">
                        <div class="block loss ${step.activeBlocks.includes('loss-block') ? 'active-loss' : ''}" id="block-loss">
                            Cross-Entropy Loss
                            <div class="dim">${currentLoss.toFixed(3)}</div>
                        </div>
                    </div>

                    <div style="display:flex;align-items:center;gap:20px;margin-bottom:20px;">
                        <div class="arrow-horizontal forward"></div>
                    </div>

                    <div class="layer" style="margin-bottom:20px;">
                        <div class="block output ${step.activeBlocks.includes('output') ? 'active-loss' : ''}">
                            Pr√©dictions
                            <div class="dim">P(next token)</div>
                        </div>
                        <span style="font-size:24px;margin:0 20px;">vs</span>
                        <div class="block target ${step.activeBlocks.includes('target') ? 'active-loss' : ''}">
                            Target
                            <div class="dim">"mange"</div>
                        </div>
                    </div>
                ` + html.split('<!-- LM Head -->')[1];
            }

            container.innerHTML = html;

            // Detail section
            document.getElementById('detail-section').innerHTML = step.detail;
        }

        function updateUI() {
            const step = steps[currentStep];

            // Update step info
            document.getElementById('step-num').textContent = currentStep + 1;
            document.getElementById('total-steps').textContent = steps.length;
            document.getElementById('step-title').textContent = step.title;
            document.getElementById('step-desc').textContent = step.desc;
            document.getElementById('step-formula').textContent = step.formula;

            // Update phase indicators
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active', 'forward', 'loss', 'backward', 'update'));
            const phaseElement = document.querySelector(`.phase:nth-child(${['forward', 'loss', 'backward', 'update'].indexOf(step.phase) + 1})`);
            if (phaseElement) {
                phaseElement.classList.add('active', step.phase);
            }

            // Update buttons
            document.getElementById('prev-btn').disabled = currentStep === 0;
            document.getElementById('next-btn').disabled = currentStep === steps.length - 1;

            // Update iteration counter on update phase completion
            if (step.phase === 'update' && step.title.includes('Nouvelle')) {
                document.getElementById('epoch-num').textContent = iteration;
            }

            // Update loss display
            document.getElementById('loss-value').textContent = currentLoss.toFixed(3);

            renderArchitecture();
        }

        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateUI();
            } else {
                // New iteration
                iteration++;
                currentLoss *= 0.92 + Math.random() * 0.06;
                currentStep = 0;
                updateUI();
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                updateUI();
            }
        }

        function goToPhase(phase) {
            const phaseStart = {
                'forward': 0,
                'loss': 5,
                'backward': 6,
                'update': 10
            };
            currentStep = phaseStart[phase];
            updateUI();
        }

        function resetAnimation() {
            currentStep = 0;
            iteration = 1;
            currentLoss = 2.45;
            stopAutoPlay();
            updateUI();
        }

        function autoPlay() {
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                document.getElementById('auto-btn').textContent = '‚è∏ Pause';
                autoPlayInterval = setInterval(() => {
                    nextStep();
                }, 1500);
            }
        }

        function stopAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                document.getElementById('auto-btn').textContent = '‚è© Auto';
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextStep();
            } else if (e.key === 'ArrowLeft') {
                prevStep();
            }
        });

        // Initialize
        updateUI();
    </script>
</body>
</html>
